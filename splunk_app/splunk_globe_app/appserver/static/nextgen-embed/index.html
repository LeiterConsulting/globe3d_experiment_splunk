<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Globe Intelligence</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }

      #container {
        width: 100%;
        height: 100%;
      }

      #bg {
        position: fixed;
        inset: 0;
        z-index: 1;
        pointer-events: none;
        background: radial-gradient(circle at 50% 50%, rgba(15, 23, 42, 0.65), rgba(0, 0, 0, 0.95));
        background-image: radial-gradient(circle at 20% 20%, rgba(14, 165, 233, 0.24), transparent 40%), radial-gradient(circle at 80% 10%, rgba(59, 130, 246, 0.16), transparent 35%), radial-gradient(circle at 50% 85%, rgba(16, 185, 129, 0.12), transparent 30%);
      }

      #bg::before,
      #bg::after {
        content: '';
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      #bg::before {
        opacity: 0;
        background-image:
          radial-gradient(circle at 8% 14%, rgba(255, 255, 255, 0.95) 0.7px, transparent 1px),
          radial-gradient(circle at 17% 81%, rgba(191, 219, 254, 0.8) 0.8px, transparent 1px),
          radial-gradient(circle at 39% 32%, rgba(255, 255, 255, 0.9) 0.7px, transparent 1px),
          radial-gradient(circle at 61% 24%, rgba(224, 242, 254, 0.75) 0.8px, transparent 1px),
          radial-gradient(circle at 74% 64%, rgba(255, 255, 255, 0.9) 0.9px, transparent 1px),
          radial-gradient(circle at 91% 43%, rgba(186, 230, 253, 0.8) 0.8px, transparent 1px),
          radial-gradient(circle at 53% 87%, rgba(255, 255, 255, 0.8) 0.8px, transparent 1px);
      }

      #bg::after {
        opacity: 0;
        background-image: radial-gradient(circle at 20% 22%, rgba(14, 165, 233, 0.24), transparent 42%), radial-gradient(circle at 80% 14%, rgba(79, 70, 229, 0.18), transparent 34%), radial-gradient(circle at 52% 85%, rgba(16, 185, 129, 0.14), transparent 30%);
      }

      #bg[data-style='deep-space']::before {
        opacity: 0.88;
      }

      #bg[data-style='deep-space']::after {
        opacity: 1;
      }

      #bg[data-style='black'] {
        background: #000;
      }

      #bg[data-style='steel'] {
        background: linear-gradient(145deg, #0f172a 0%, #1e293b 48%, #0b1220 100%);
      }

      #bg[data-style='steel']::after {
        opacity: 0.65;
        background-image: radial-gradient(circle at 20% 20%, rgba(148, 163, 184, 0.22), transparent 42%), radial-gradient(circle at 79% 10%, rgba(71, 85, 105, 0.2), transparent 35%), radial-gradient(circle at 50% 86%, rgba(100, 116, 139, 0.17), transparent 34%);
      }

      #container {
        position: relative;
        z-index: 2;
      }

      #overlay {
        position: absolute;
        top: 12px;
        left: 12px;
        z-index: 10;
        min-width: 260px;
        max-width: min(48vw, 460px);
        border-radius: 12px;
        background: rgba(2, 6, 23, 0.58);
        border: 1px solid rgba(56, 189, 248, 0.35);
        padding: 10px 12px;
        backdrop-filter: blur(4px);
        color: #dbeafe;
      }

      #title {
        font-size: 14px;
        font-weight: 800;
        letter-spacing: 0.5px;
      }

      #subtitle {
        margin-top: 4px;
        font-size: 12px;
        color: #93c5fd;
      }

      #focus {
        margin-top: 8px;
        font-size: 12px;
        color: #a5f3fc;
      }

      #legend {
        margin-top: 8px;
        font-size: 11px;
        color: #bfdbfe;
        line-height: 1.35;
      }
    </style>
  </head>
  <body>
    <div id="bg"></div>
    <div id="container"></div>
    <div id="overlay">
      <div id="title">Geo Intelligence</div>
      <div id="subtitle">Awaiting stream...</div>
      <div id="focus"></div>
      <div id="legend"></div>
    </div>

    <script>
      window.i18n_register = window.i18n_register || function () {}
    </script>
    <script src="/static/app/splunk_globe_app/vendor/webgl-globe/third-party/Detector.js"></script>
    <script src="/static/app/splunk_globe_app/vendor/webgl-globe/third-party/three.min.js"></script>
    <script src="/static/app/splunk_globe_app/vendor/webgl-globe/third-party/Tween.js"></script>
    <script src="/static/app/splunk_globe_app/vendor/webgl-globe/globe.js"></script>
    <script>
      ;(function () {
        var container = document.getElementById('container')
        var bgEl = document.getElementById('bg')
        var titleEl = document.getElementById('title')
        var subtitleEl = document.getElementById('subtitle')
        var focusEl = document.getElementById('focus')
        var legendEl = document.getElementById('legend')

        if (!window.Detector || !Detector.webgl) {
          subtitleEl.textContent = 'WebGL unavailable in this browser session.'
          if (window.Detector && Detector.addGetWebGLMessage) Detector.addGetWebGLMessage()
          return
        }

        var currentEarthStyle = 'grey'

        function colorFn(value) {
          var c = new THREE.Color()
          var x = Number(value)
          if (!Number.isFinite(x)) x = 0.4
          x = Math.max(0, Math.min(1, x))
          if (currentEarthStyle === 'neon') {
            c.setHSL(0.78 - x * 0.42, 1.0, 0.58)
          } else if (currentEarthStyle === 'atlas') {
            c.setHSL(0.12 - x * 0.08, 0.72, 0.52)
          } else if (currentEarthStyle === 'blueprint') {
            c.setHSL(0.58 - x * 0.2, 0.92, 0.54)
          } else {
            c.setHSL(0.62 - x * 0.08, 0.2, 0.58)
          }
          return c
        }

        var globe = new DAT.Globe(container, {
          imgDir: '../vendor/webgl-globe/',
          colorFn: colorFn,
          minDistance: 220,
          maxDistance: 1000,
        })
        globe.animate()
        if (window.TWEEN && typeof TWEEN.start === 'function') {
          TWEEN.start()
        }

        var frameTimer = null
        var highlightObject = null
        var regionOutlineObject = null
        var selectedRegionOutlineObject = null
        var contextOutlineObject = null
        var selectedContextOutlineObject = null
        var arcObject = null
        var arcHeadObject = null
        var flowObject = null
        var temperatureObject = null
        var anchorObject = null
        var groundHeatObject = null
        var baseDotsObject = null
        var cityIndicatorObject = null
        var cityIndicatorHaloObject = null
        var countyLineObject = null
        var groupObjects = []
        var currentFrame = 0
        var currentZoomScale = 1
        var earthStyleShell = null
        var landReferenceShell = null
        var starfieldShell = null
        var graticuleObject = null
        var focusAnchorObject = null
        var pointerDown = null
        var regionQualityDebug = false
        var currentViewLevel = 'continent'
        var desiredAutoRotateEnabled = false
        var desiredAutoRotateSpeed = 0
        var focusHoldUntil = 0
        var lastFocusRequestId = null
        var densifyCache = new Map()
        var densifyCacheHits = 0
        var densifyCacheMisses = 0
        var renderTiming = { count: 0, totalMs: 0, maxMs: 0, lastMs: 0 }
        var currentRenderPolicy = {
          maxArcs: 18,
          maxFlow: 60,
          maxGroups: 10,
          maxCityIndicators: 90,
          baseDotScale: 1,
          cityIndicatorScale: 1,
          countyContextBoost: 1,
        }

        function updateRenderPolicy() {
          var distance = Number(typeof globe.getZoomDistance === 'function' ? globe.getZoomDistance() : NaN)
          var closeFactor = Number.isFinite(distance) ? Math.max(0, Math.min(1, (760 - distance) / 520)) : 0.25

          if (currentViewLevel === 'city') {
            currentRenderPolicy = {
              maxArcs: 5,
              maxFlow: 14,
              maxGroups: 4,
              maxCityIndicators: 120,
              baseDotScale: 0.85,
              cityIndicatorScale: 1.35,
              countyContextBoost: 1.45,
            }
            return
          }

          if (currentViewLevel === 'county') {
            currentRenderPolicy = {
              maxArcs: 7,
              maxFlow: 22,
              maxGroups: 5,
              maxCityIndicators: 105,
              baseDotScale: 0.92,
              cityIndicatorScale: 1.2,
              countyContextBoost: 1.35,
            }
            return
          }

          if (currentViewLevel === 'state') {
            currentRenderPolicy = {
              maxArcs: 10,
              maxFlow: 32,
              maxGroups: 6,
              maxCityIndicators: 80,
              baseDotScale: 0.98,
              cityIndicatorScale: 1.08,
              countyContextBoost: 1.12,
            }
            return
          }

          currentRenderPolicy = {
            maxArcs: 18,
            maxFlow: 60,
            maxGroups: 10,
            maxCityIndicators: Math.round(70 + closeFactor * 20),
            baseDotScale: 1,
            cityIndicatorScale: 1,
            countyContextBoost: 1,
          }
        }

        function localLevelRotateFactor(level) {
          if (level === 'city') return 0.08
          if (level === 'county') return 0.12
          if (level === 'state') return 0.2
          if (level === 'country') return 0.45
          return 1
        }

        function applyAdaptiveAutoRotate() {
          if (typeof globe.setAutoRotateSpeed !== 'function') return
          if (!desiredAutoRotateEnabled) {
            globe.setAutoRotateSpeed(0)
            return
          }

          var now = Date.now()
          if (now < focusHoldUntil) {
            globe.setAutoRotateSpeed(0)
            return
          }

          var distance = Number(typeof globe.getZoomDistance === 'function' ? globe.getZoomDistance() : NaN)
          var distanceFactor = 1
          if (Number.isFinite(distance)) {
            distanceFactor = Math.max(0.18, Math.min(1, (distance - 260) / 620))
          }

          var levelFactor = localLevelRotateFactor(currentViewLevel)
          var speed = desiredAutoRotateSpeed * distanceFactor * levelFactor
          globe.setAutoRotateSpeed(Math.max(0, Math.min(0.12, speed)))
        }

        function disposeObjectTree(object) {
          if (!object) return
          if (object.children && object.children.length) {
            for (var idx = 0; idx < object.children.length; idx++) {
              disposeObjectTree(object.children[idx])
            }
          }
          if (object.geometry && object.geometry.dispose) object.geometry.dispose()
          if (object.material && object.material.dispose) object.material.dispose()
        }

        ;(function createEarthStyleShell() {
          var geometry = new THREE.SphereGeometry(201.3, 40, 30)
          var material = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0, transparent: true, depthWrite: false })
          earthStyleShell = new THREE.Mesh(geometry, material)
          globe.scene.add(earthStyleShell)
        })()

        ;(function createLandReferenceShell() {
          var texture = THREE.ImageUtils.loadTexture('/static/app/splunk_globe_app/vendor/webgl-globe/world.jpg')
          texture.minFilter = THREE.LinearMipMapLinearFilter
          texture.magFilter = THREE.LinearFilter
          var geometry = new THREE.SphereGeometry(200.9, 64, 48)
          var material = new THREE.MeshBasicMaterial({
            map: texture,
            color: 0xdbeafe,
            opacity: 0.0,
            transparent: true,
            depthWrite: false,
          })
          landReferenceShell = new THREE.Mesh(geometry, material)
          globe.scene.add(landReferenceShell)
        })()

        ;(function createStarfieldShell() {
          var texture = THREE.ImageUtils.loadTexture('/static/app/splunk_globe_app/vendor/webgl-globe/starfield.jpg')
          var geometry = new THREE.SphereGeometry(4200, 48, 36)
          var material = new THREE.MeshBasicMaterial({
            map: texture,
            color: 0xffffff,
            opacity: 0.38,
            transparent: true,
            depthWrite: false,
            side: THREE.BackSide,
          })
          starfieldShell = new THREE.Mesh(geometry, material)
          globe.scene.add(starfieldShell)
        })()

        ;(function createGraticule() {
          var geometry = new THREE.Geometry()
          var radius = 203.2

          for (var lat = -80; lat <= 80; lat += 10) {
            var prevLat = null
            for (var lon = -180; lon <= 180; lon += 5) {
              var vertexLat = latLonToVector(lat, lon, radius)
              if (prevLat) geometry.vertices.push(prevLat, vertexLat)
              prevLat = vertexLat
            }
          }

          for (var lon = -180; lon < 180; lon += 10) {
            var prevLon = null
            for (var lat = -85; lat <= 85; lat += 5) {
              var vertexLon = latLonToVector(lat, lon, radius)
              if (prevLon) geometry.vertices.push(prevLon, vertexLon)
              prevLon = vertexLon
            }
          }

          var material = new THREE.LineBasicMaterial({ color: 0x93c5fd, opacity: 0.1, transparent: true, depthWrite: false })
          graticuleObject = new THREE.Line(geometry, material, THREE.LinePieces)
          globe.scene.add(graticuleObject)
        })()

        function setFocusAnchor(lat, lon) {
          if (focusAnchorObject) {
            globe.scene.remove(focusAnchorObject)
            if (focusAnchorObject.geometry && focusAnchorObject.geometry.dispose) focusAnchorObject.geometry.dispose()
            if (focusAnchorObject.material && focusAnchorObject.material.dispose) focusAnchorObject.material.dispose()
            focusAnchorObject = null
          }

          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return
          var geometry = new THREE.Geometry()
          geometry.vertices.push(latLonToVector(lat, lon, 208.2))
          var material = new THREE.PointCloudMaterial({
            color: 0xfef3c7,
            size: 7.4,
            opacity: 0.95,
            transparent: true,
            depthWrite: false,
          })
          focusAnchorObject = new THREE.PointCloud(geometry, material)
          globe.scene.add(focusAnchorObject)
        }

        function latLonToVector(lat, lon, radius) {
          var phi = ((90 - lat) * Math.PI) / 180
          var theta = ((180 - lon) * Math.PI) / 180
          return new THREE.Vector3(radius * Math.sin(phi) * Math.cos(theta), radius * Math.cos(phi), radius * Math.sin(phi) * Math.sin(theta))
        }

        function unwrapLonDelta(startLon, endLon) {
          var delta = endLon - startLon
          while (delta > 180) delta -= 360
          while (delta < -180) delta += 360
          return delta
        }

        function densifyRing(coords, maxStepDegrees) {
          if (!Array.isArray(coords) || coords.length < 2) return []
          var dense = []
          var step = Math.max(0.4, Number(maxStepDegrees) || 1.2)

          var cacheKey =
            step.toFixed(2) +
            '|' +
            coords
              .map(function (pair) {
                if (!Array.isArray(pair) || pair.length < 2) return 'x'
                return Number(pair[0]).toFixed(3) + ',' + Number(pair[1]).toFixed(3)
              })
              .join(';')

          var cached = densifyCache.get(cacheKey)
          if (cached) {
            densifyCacheHits += 1
            return cached
          }
          densifyCacheMisses += 1

          for (var idx = 0; idx < coords.length - 1; idx++) {
            var start = coords[idx]
            var end = coords[idx + 1]
            if (!Array.isArray(start) || !Array.isArray(end) || start.length < 2 || end.length < 2) continue

            var startLon = Number(start[0])
            var startLat = Number(start[1])
            var endLon = Number(end[0])
            var endLat = Number(end[1])
            if (!Number.isFinite(startLon) || !Number.isFinite(startLat) || !Number.isFinite(endLon) || !Number.isFinite(endLat)) continue

            if (!dense.length) dense.push([startLon, startLat])

            var dLon = unwrapLonDelta(startLon, endLon)
            var dLat = endLat - startLat
            var segmentSpan = Math.max(Math.abs(dLon), Math.abs(dLat))
            var segments = Math.max(1, Math.ceil(segmentSpan / step))
            for (var s = 1; s <= segments; s++) {
              var t = s / segments
              var nextLon = startLon + dLon * t
              while (nextLon > 180) nextLon -= 360
              while (nextLon < -180) nextLon += 360
              var nextLat = startLat + dLat * t
              dense.push([nextLon, nextLat])
            }
          }

          if (densifyCache.size > 2400) {
            var oldestKey = densifyCache.keys().next().value
            if (oldestKey) densifyCache.delete(oldestKey)
          }
          densifyCache.set(cacheKey, dense)
          return dense
        }

        function clearHighlights() {
          if (!highlightObject) return
          globe.scene.remove(highlightObject)
          if (highlightObject.geometry && highlightObject.geometry.dispose) highlightObject.geometry.dispose()
          if (highlightObject.material && highlightObject.material.dispose) highlightObject.material.dispose()
          highlightObject = null
        }

        function clearRegionOutlines() {
          if (regionOutlineObject) {
            globe.scene.remove(regionOutlineObject)
            disposeObjectTree(regionOutlineObject)
            regionOutlineObject = null
          }
          if (selectedRegionOutlineObject) {
            globe.scene.remove(selectedRegionOutlineObject)
            disposeObjectTree(selectedRegionOutlineObject)
            selectedRegionOutlineObject = null
          }
          if (contextOutlineObject) {
            globe.scene.remove(contextOutlineObject)
            disposeObjectTree(contextOutlineObject)
            contextOutlineObject = null
          }
          if (selectedContextOutlineObject) {
            globe.scene.remove(selectedContextOutlineObject)
            disposeObjectTree(selectedContextOutlineObject)
            selectedContextOutlineObject = null
          }
          if (countyLineObject) {
            globe.scene.remove(countyLineObject)
            disposeObjectTree(countyLineObject)
            countyLineObject = null
          }
        }

        function clearOverlayObject(refName) {
          var object = null
          if (refName === 'arc') object = arcObject
          if (refName === 'arcHeads') object = arcHeadObject
          if (refName === 'flow') object = flowObject
          if (refName === 'temperature') object = temperatureObject
          if (refName === 'anchor') object = anchorObject
          if (refName === 'groundHeat') object = groundHeatObject
          if (refName === 'baseDots') object = baseDotsObject
          if (refName === 'cityIndicators') object = cityIndicatorObject
          if (refName === 'cityIndicatorHalos') object = cityIndicatorHaloObject
          if (!object) return
          globe.scene.remove(object)
          if (object.geometry && object.geometry.dispose) object.geometry.dispose()
          if (object.material && object.material.dispose) object.material.dispose()
          if (refName === 'arc') arcObject = null
          if (refName === 'arcHeads') arcHeadObject = null
          if (refName === 'flow') flowObject = null
          if (refName === 'temperature') temperatureObject = null
          if (refName === 'anchor') anchorObject = null
          if (refName === 'groundHeat') groundHeatObject = null
          if (refName === 'baseDots') baseDotsObject = null
          if (refName === 'cityIndicators') cityIndicatorObject = null
          if (refName === 'cityIndicatorHalos') cityIndicatorHaloObject = null
        }

        function clearGroupObjects() {
          for (var i = 0; i < groupObjects.length; i++) {
            var object = groupObjects[i]
            globe.scene.remove(object)
            if (object.geometry && object.geometry.dispose) object.geometry.dispose()
            if (object.material && object.material.dispose) object.material.dispose()
          }
          groupObjects = []
        }

        function clearAdvancedOverlays() {
          clearOverlayObject('arc')
          clearOverlayObject('arcHeads')
          clearOverlayObject('flow')
          clearOverlayObject('temperature')
          clearOverlayObject('anchor')
          clearOverlayObject('groundHeat')
          clearOverlayObject('baseDots')
          clearOverlayObject('cityIndicators')
          clearOverlayObject('cityIndicatorHalos')
          clearGroupObjects()
        }

        function updateZoomResponsiveScales() {
          var distance = Number(typeof globe.getZoomDistance === 'function' ? globe.getZoomDistance() : NaN)
          if (!Number.isFinite(distance)) return
          var distanceScale = Math.max(0.75, Math.min(2.25, 980 / Math.max(220, distance)))
          var zoomScale = distanceScale * currentZoomScale
          for (var i = 0; i < groupObjects.length; i++) {
            if (groupObjects[i] && groupObjects[i].material) {
              groupObjects[i].material.size = Math.max(1.8, 2.2 * zoomScale)
            }
          }
          if (highlightObject && highlightObject.material) highlightObject.material.size = Math.max(2.4, 3.2 * zoomScale)
          if (temperatureObject && temperatureObject.material) temperatureObject.material.size = Math.max(2.0, 2.6 * zoomScale)
          if (anchorObject && anchorObject.material) anchorObject.material.size = Math.max(2.4, 2.8 * zoomScale)
          if (groundHeatObject && groundHeatObject.material) groundHeatObject.material.size = Math.max(4.8, 6.2 * zoomScale)
          if (baseDotsObject && baseDotsObject.material) baseDotsObject.material.size = Math.max(2.1, 2.9 * zoomScale)
          if (cityIndicatorObject && cityIndicatorObject.material) cityIndicatorObject.material.size = Math.max(3.8, 5.4 * zoomScale * currentRenderPolicy.cityIndicatorScale)
          if (cityIndicatorHaloObject && cityIndicatorHaloObject.material) cityIndicatorHaloObject.material.size = Math.max(6.2, 8.8 * zoomScale * currentRenderPolicy.cityIndicatorScale)
          if (arcHeadObject && arcHeadObject.material) arcHeadObject.material.size = Math.max(3.2, 4.8 * zoomScale)
          if (focusAnchorObject && focusAnchorObject.material) focusAnchorObject.material.size = Math.max(6.2, 7.4 * zoomScale)
        }

        function updateReferenceOverlays(view) {
          var level = currentViewLevel
          var distance = Number(typeof globe.getZoomDistance === 'function' ? globe.getZoomDistance() : NaN)
          var closeFactor = Number.isFinite(distance) ? Math.max(0, Math.min(1, (760 - distance) / 520)) : 0.25

          var levelBase = 0.1
          if (level === 'country') levelBase = 0.14
          else if (level === 'state') levelBase = 0.2
          else if (level === 'county') levelBase = 0.26
          else if (level === 'city') levelBase = 0.31

          if (graticuleObject && graticuleObject.material) {
            graticuleObject.material.opacity = Math.max(0.06, Math.min(0.62, levelBase + closeFactor * 0.34))
          }

          if (starfieldShell && starfieldShell.material) {
            var bg = view && typeof view.backgroundStyle === 'string' ? view.backgroundStyle : 'deep-space'
            var bgBase = bg === 'black' ? 0.26 : bg === 'steel' ? 0.2 : 0.38
            starfieldShell.material.opacity = Math.max(0.14, Math.min(0.52, bgBase - closeFactor * 0.08))
          }

          if (landReferenceShell && landReferenceShell.material) {
            var landBase = level === 'city' ? 0.36 : level === 'county' ? 0.3 : level === 'state' ? 0.24 : 0.14
            landReferenceShell.material.opacity = Math.max(0.06, Math.min(0.5, landBase + closeFactor * 0.18))
          }
        }

        function renderRegionLayer(layer) {
          clearRegionOutlines()
          if (!layer || typeof layer !== 'object') return

          var features = Array.isArray(layer.features) ? layer.features : []
          if (!features.length) return { total: 0, low: 0, medium: 0, high: 0, bbox: 0, degenerate: 0, hull: 0 }

          var selectedKey = typeof layer.selectedKey === 'string' ? layer.selectedKey : ''
          var summary = { total: 0, low: 0, medium: 0, high: 0, bbox: 0, degenerate: 0, hull: 0 }

          if (regionQualityDebug === true) {
            var debugNormalGroup = new THREE.Object3D()
            var debugSelectedGroup = new THREE.Object3D()

            for (var i = 0; i < features.length; i++) {
              var feature = features[i]
              if (!feature || typeof feature !== 'object') continue
              var key = typeof feature.key === 'string' ? feature.key : ''
              var paths = Array.isArray(feature.paths) ? feature.paths : []
              if (!paths.length) continue

              var geometry = new THREE.Geometry()
              for (var p = 0; p < paths.length; p++) {
                var coords = paths[p]
                if (!Array.isArray(coords) || coords.length < 2) continue

                var ring = []
                var denseCoords = densifyRing(coords, 1.1)
                var ringCoords = denseCoords.length ? denseCoords : coords
                for (var j = 0; j < ringCoords.length; j++) {
                  var pair = ringCoords[j]
                  if (!Array.isArray(pair) || pair.length < 2) continue
                  var lon = Number(pair[0])
                  var lat = Number(pair[1])
                  if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
                  ring.push(latLonToVector(lat, lon, 201.9))
                }
                if (ring.length < 2) continue
                for (var r = 0; r < ring.length - 1; r++) {
                  geometry.vertices.push(ring[r], ring[r + 1])
                }
                var first = ring[0]
                var last = ring[ring.length - 1]
                if (first.distanceTo(last) >= 0.0001) {
                  geometry.vertices.push(last, first)
                }
              }

              if (!geometry.vertices.length) continue
              var quality = Math.max(0, Math.min(1, Number(feature.qualityScore) || 0))
              var strategy = String(feature.geometryStrategy || 'unknown')
              if (strategy === 'bbox-fallback') summary.bbox += 1
              else if (strategy === 'bbox-degenerate') summary.degenerate += 1
              else if (strategy === 'convex-hull') summary.hull += 1
              if (quality < 0.35) summary.low += 1
              else if (quality < 0.65) summary.medium += 1
              else summary.high += 1
              summary.total += 1

              var color = quality < 0.35 ? 0xef4444 : quality < 0.65 ? 0xf59e0b : 0x22c55e
              var isSelected = key && key === selectedKey
              var material = new THREE.LineBasicMaterial({
                color: isSelected ? 0xf8fafc : color,
                opacity: isSelected ? 0.98 : 0.72,
                transparent: true,
              })
              var line = new THREE.Line(geometry, material, THREE.LinePieces)
              if (isSelected) debugSelectedGroup.add(line)
              else debugNormalGroup.add(line)
            }

            if (debugNormalGroup.children.length) {
              regionOutlineObject = debugNormalGroup
              globe.scene.add(regionOutlineObject)
            }
            if (debugSelectedGroup.children.length) {
              selectedRegionOutlineObject = debugSelectedGroup
              globe.scene.add(selectedRegionOutlineObject)
            }
            return summary
          }

          var normalGeometry = new THREE.Geometry()
          var selectedGeometry = new THREE.Geometry()

          for (var i = 0; i < features.length; i++) {
            var feature = features[i]
            if (!feature || typeof feature !== 'object') continue
            var key = typeof feature.key === 'string' ? feature.key : ''
            var paths = Array.isArray(feature.paths) ? feature.paths : []
            if (!paths.length) continue

            var targetGeometry = key && key === selectedKey ? selectedGeometry : normalGeometry

            for (var p = 0; p < paths.length; p++) {
              var coords = paths[p]
              if (!Array.isArray(coords) || coords.length < 2) continue

              var ring = []
              var denseCoords = densifyRing(coords, 1.1)
              var ringCoords = denseCoords.length ? denseCoords : coords
              for (var j = 0; j < ringCoords.length; j++) {
                var pair = ringCoords[j]
                if (!Array.isArray(pair) || pair.length < 2) continue
                var lon = Number(pair[0])
                var lat = Number(pair[1])
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
                ring.push(latLonToVector(lat, lon, 201.9))
              }

              if (ring.length < 2) continue
              for (var r = 0; r < ring.length - 1; r++) {
                targetGeometry.vertices.push(ring[r], ring[r + 1])
              }
              var first = ring[0]
              var last = ring[ring.length - 1]
              var closeEnough = first.distanceTo(last) < 0.0001
              if (!closeEnough) {
                targetGeometry.vertices.push(last, first)
              }
            }
          }

          if (normalGeometry.vertices.length) {
            var normalMaterial = new THREE.LineBasicMaterial({ color: 0x38bdf8, opacity: Math.min(0.9, 0.45 * boundaryOpacityBoost()), transparent: true })
            regionOutlineObject = new THREE.Line(normalGeometry, normalMaterial, THREE.LinePieces)
            globe.scene.add(regionOutlineObject)
          }

          if (selectedGeometry.vertices.length) {
            selectedRegionOutlineObject = createSelectedBoundaryEmphasis(
              selectedGeometry,
              0xf59e0b,
              Math.min(1, 0.95 * boundaryOpacityBoost()),
              0xfef3c7,
              Math.min(0.95, 0.48 * boundaryOpacityBoost()),
            )
            globe.scene.add(selectedRegionOutlineObject)
          }
          return summary
        }

        function contextThemeStyle(theme) {
          if (theme === 'amber-contrast') {
            return {
              normalColor: 0xf59e0b,
              selectedColor: 0xfef3c7,
              normalOpacity: 0.34,
              selectedOpacity: 0.82,
            }
          }
          if (theme === 'violet-night') {
            return {
              normalColor: 0xa78bfa,
              selectedColor: 0xe9d5ff,
              normalOpacity: 0.32,
              selectedOpacity: 0.8,
            }
          }
          return {
            normalColor: 0x22d3ee,
            selectedColor: 0xe0f2fe,
            normalOpacity: 0.3,
            selectedOpacity: 0.78,
          }
        }

        function boundaryOpacityBoost() {
          if (currentViewLevel === 'city') return 1.55
          if (currentViewLevel === 'county') return 1.45
          if (currentViewLevel === 'state') return 1.28
          return 1
        }

        function selectedBoundaryMarkerSize() {
          if (currentViewLevel === 'city') return 2.6
          if (currentViewLevel === 'county') return 2.2
          if (currentViewLevel === 'state') return 2.0
          return 1.6
        }

        function createSelectedBoundaryEmphasis(geometry, coreColor, coreOpacity, glowColor, glowOpacity) {
          var group = new THREE.Object3D()
          var coreLine = new THREE.Line(
            geometry,
            new THREE.LineBasicMaterial({ color: coreColor, opacity: coreOpacity, transparent: true }),
            THREE.LinePieces,
          )
          group.add(coreLine)

          var glowGeometry = new THREE.Geometry()
          for (var i = 0; i < geometry.vertices.length; i++) {
            glowGeometry.vertices.push(geometry.vertices[i].clone())
          }
          var glowPoints = new THREE.PointCloud(
            glowGeometry,
            new THREE.PointCloudMaterial({
              color: glowColor,
              size: selectedBoundaryMarkerSize(),
              opacity: glowOpacity,
              transparent: true,
              depthWrite: false,
            }),
          )
          group.add(glowPoints)
          return group
        }

        function renderContextLayer(layer, theme) {
          if (!layer || typeof layer !== 'object') return { total: 0, low: 0, medium: 0, high: 0, bbox: 0, degenerate: 0, hull: 0 }

          var features = Array.isArray(layer.features) ? layer.features : []
          if (!features.length) return { total: 0, low: 0, medium: 0, high: 0, bbox: 0, degenerate: 0, hull: 0 }

          var selectedKey = typeof layer.selectedKey === 'string' ? layer.selectedKey : ''
          var isCountyContext = layer.level === 'county'
          var summary = { total: 0, low: 0, medium: 0, high: 0, bbox: 0, degenerate: 0, hull: 0 }
          var style = contextThemeStyle(theme)

          if (regionQualityDebug === true) {
            var debugNormalGroup = new THREE.Object3D()
            var debugSelectedGroup = new THREE.Object3D()

            for (var i = 0; i < features.length; i++) {
              var feature = features[i]
              if (!feature || typeof feature !== 'object') continue
              var key = typeof feature.key === 'string' ? feature.key : ''
              var paths = Array.isArray(feature.paths) ? feature.paths : []
              if (!paths.length) continue

              var geometry = new THREE.Geometry()
              for (var p = 0; p < paths.length; p++) {
                var coords = paths[p]
                if (!Array.isArray(coords) || coords.length < 2) continue

                var ring = []
                var denseCoords = densifyRing(coords, 1.1)
                var ringCoords = denseCoords.length ? denseCoords : coords
                for (var j = 0; j < ringCoords.length; j++) {
                  var pair = ringCoords[j]
                  if (!Array.isArray(pair) || pair.length < 2) continue
                  var lon = Number(pair[0])
                  var lat = Number(pair[1])
                  if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
                  ring.push(latLonToVector(lat, lon, 202.8))
                }
                if (ring.length < 2) continue
                for (var r = 0; r < ring.length - 1; r++) {
                  geometry.vertices.push(ring[r], ring[r + 1])
                }
                var first = ring[0]
                var last = ring[ring.length - 1]
                if (first.distanceTo(last) >= 0.0001) {
                  geometry.vertices.push(last, first)
                }
              }

              if (!geometry.vertices.length) continue
              var quality = Math.max(0, Math.min(1, Number(feature.qualityScore) || 0))
              var strategy = String(feature.geometryStrategy || 'unknown')
              if (strategy === 'bbox-fallback') summary.bbox += 1
              else if (strategy === 'bbox-degenerate') summary.degenerate += 1
              else if (strategy === 'convex-hull') summary.hull += 1
              if (quality < 0.35) summary.low += 1
              else if (quality < 0.65) summary.medium += 1
              else summary.high += 1
              summary.total += 1

              var color = quality < 0.35 ? 0xef4444 : quality < 0.65 ? 0xf59e0b : 0x22c55e
              var isSelected = key && key === selectedKey
              var material = new THREE.LineBasicMaterial({
                color: isSelected ? style.selectedColor : color,
                opacity: isSelected ? 0.96 : 0.58,
                transparent: true,
              })
              var line = new THREE.Line(geometry, material, THREE.LinePieces)
              if (isSelected) debugSelectedGroup.add(line)
              else debugNormalGroup.add(line)
            }

            if (debugNormalGroup.children.length) {
              contextOutlineObject = debugNormalGroup
              globe.scene.add(contextOutlineObject)
            }
            if (debugSelectedGroup.children.length) {
              selectedContextOutlineObject = debugSelectedGroup
              globe.scene.add(selectedContextOutlineObject)
            }
            return summary
          }

          var normalGeometry = new THREE.Geometry()
          var selectedGeometry = new THREE.Geometry()

          for (var i = 0; i < features.length; i++) {
            var feature = features[i]
            if (!feature || typeof feature !== 'object') continue
            var key = typeof feature.key === 'string' ? feature.key : ''
            var paths = Array.isArray(feature.paths) ? feature.paths : []
            if (!paths.length) continue

            var targetGeometry = key && key === selectedKey ? selectedGeometry : normalGeometry

            for (var p = 0; p < paths.length; p++) {
              var coords = paths[p]
              if (!Array.isArray(coords) || coords.length < 2) continue

              var ring = []
              var denseCoords = densifyRing(coords, 1.1)
              var ringCoords = denseCoords.length ? denseCoords : coords
              for (var j = 0; j < ringCoords.length; j++) {
                var pair = ringCoords[j]
                if (!Array.isArray(pair) || pair.length < 2) continue
                var lon = Number(pair[0])
                var lat = Number(pair[1])
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
                ring.push(latLonToVector(lat, lon, 202.8))
              }

              if (ring.length < 2) continue
              for (var r = 0; r < ring.length - 1; r++) {
                targetGeometry.vertices.push(ring[r], ring[r + 1])
              }
              var first = ring[0]
              var last = ring[ring.length - 1]
              var closeEnough = first.distanceTo(last) < 0.0001
              if (!closeEnough) {
                targetGeometry.vertices.push(last, first)
              }
            }
            summary.total += 1
          }

          if (normalGeometry.vertices.length) {
            var contextBoost = isCountyContext ? currentRenderPolicy.countyContextBoost : 1
            var normalMaterial = new THREE.LineBasicMaterial({ color: style.normalColor, opacity: Math.min(0.9, style.normalOpacity * boundaryOpacityBoost() * contextBoost), transparent: true })
            contextOutlineObject = new THREE.Line(normalGeometry, normalMaterial, THREE.LinePieces)
            globe.scene.add(contextOutlineObject)
          }

          if (selectedGeometry.vertices.length) {
            var selectedBoost = isCountyContext ? currentRenderPolicy.countyContextBoost : 1
            selectedContextOutlineObject = createSelectedBoundaryEmphasis(
              selectedGeometry,
              style.selectedColor,
              Math.min(1, style.selectedOpacity * boundaryOpacityBoost() * selectedBoost),
              0xf8fafc,
              Math.min(0.92, 0.42 * boundaryOpacityBoost() * selectedBoost),
            )
            globe.scene.add(selectedContextOutlineObject)
          }

          return summary
        }

        function renderHighlights(points, pointOpacity) {
          clearHighlights()
          if (!Array.isArray(points) || !points.length) return

          var geometry = new THREE.Geometry()
          for (var i = 0; i < points.length; i++) {
            var item = points[i]
            if (!Array.isArray(item) || item.length < 2) continue
            var lat = Number(item[0])
            var lon = Number(item[1])
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
            var phi = ((90 - lat) * Math.PI) / 180
            var theta = ((180 - lon) * Math.PI) / 180
            var r = 203.8
            var x = r * Math.sin(phi) * Math.cos(theta)
            var y = r * Math.cos(phi)
            var z = r * Math.sin(phi) * Math.sin(theta)
            geometry.vertices.push(new THREE.Vector3(x, y, z))
          }

          if (!geometry.vertices.length) return

          var material = new THREE.PointCloudMaterial({
            color: 0x22d3ee,
            size: 3.8,
            transparent: true,
            opacity: Math.max(0.35, Math.min(1, Number(pointOpacity) || 1)),
            depthWrite: false,
          })
          highlightObject = new THREE.PointCloud(geometry, material)
          globe.scene.add(highlightObject)
        }

        function blendColor(fromHex, toHex, t) {
          var from = new THREE.Color(fromHex)
          var to = new THREE.Color(toHex)
          var clamped = Math.max(0, Math.min(1, Number(t) || 0))
          from.r += (to.r - from.r) * clamped
          from.g += (to.g - from.g) * clamped
          from.b += (to.b - from.b) * clamped
          return from
        }

        function latLonToUnit(lat, lon) {
          var phi = ((90 - lat) * Math.PI) / 180
          var theta = ((180 - lon) * Math.PI) / 180
          var x = Math.sin(phi) * Math.cos(theta)
          var y = Math.cos(phi)
          var z = Math.sin(phi) * Math.sin(theta)
          return new THREE.Vector3(x, y, z).normalize()
        }

        function slerpUnitVector(a, b, t) {
          var dot = Math.max(-1, Math.min(1, a.dot(b)))
          var omega = Math.acos(dot)
          var sinOmega = Math.sin(omega)
          if (!Number.isFinite(omega) || omega < 1e-5 || Math.abs(sinOmega) < 1e-5) {
            return a.clone().lerp(b, t).normalize()
          }
          var scaleA = Math.sin((1 - t) * omega) / sinOmega
          var scaleB = Math.sin(t * omega) / sinOmega
          return a.clone().multiplyScalar(scaleA).add(b.clone().multiplyScalar(scaleB)).normalize()
        }

        function buildGreatCircleArc(fromLat, fromLon, toLat, toLon, weight) {
          var startUnit = latLonToUnit(fromLat, fromLon)
          var endUnit = latLonToUnit(toLat, toLon)
          var dot = Math.max(-1, Math.min(1, startUnit.dot(endUnit)))
          var omega = Math.acos(dot)
          var segments = Math.max(10, Math.min(48, Math.round(12 + (omega / Math.PI) * 24 + weight * 12)))
          var arcHeight = 7 + weight * 16 + (omega / Math.PI) * 9

          var points = []
          for (var i = 0; i <= segments; i++) {
            var t = i / segments
            var unit = slerpUnitVector(startUnit, endUnit, t)
            var lift = Math.sin(Math.PI * t) * arcHeight
            points.push(unit.multiplyScalar(204 + lift))
          }
          return points
        }

        function renderConnections(data) {
          clearOverlayObject('arc')
          clearOverlayObject('arcHeads')
          if (!data || data.enabled !== true) return 0
          var arcs = Array.isArray(data.arcs) ? data.arcs : []
          if (!arcs.length) return 0
          arcs = arcs.slice(0, currentRenderPolicy.maxArcs)

          var geometry = new THREE.Geometry()
          var headGeometry = new THREE.Geometry()
          var colors = []
          var headColors = []
          var renderedArcs = 0
          for (var i = 0; i < arcs.length; i++) {
            var arc = arcs[i]
            if (!arc || !Array.isArray(arc.from) || !Array.isArray(arc.to)) continue
            var fromLat = Number(arc.from[0])
            var fromLon = Number(arc.from[1])
            var toLat = Number(arc.to[0])
            var toLon = Number(arc.to[1])
            if (!Number.isFinite(fromLat) || !Number.isFinite(fromLon) || !Number.isFinite(toLat) || !Number.isFinite(toLon)) continue

            var weight = Math.max(0.1, Math.min(1, Number(arc.weight) || 0.3))
            var curve = buildGreatCircleArc(fromLat, fromLon, toLat, toLon, weight)
            if (curve.length < 2) continue

            for (var p = 0; p < curve.length - 1; p++) {
              var progress = (p + 1) / (curve.length - 1)
              var color = blendColor(0x38bdf8, 0xf59e0b, Math.max(weight * 0.4, progress * 0.9))
              geometry.vertices.push(curve[p], curve[p + 1])
              colors.push(color, color)
            }

            var headIndex = Math.max(0, Math.min(curve.length - 1, Math.floor(curve.length * 0.88)))
            headGeometry.vertices.push(curve[headIndex].clone())
            headColors.push(blendColor(0xf59e0b, 0xfef3c7, 0.65 + weight * 0.3))
            renderedArcs += 1
          }

          if (!geometry.vertices.length) return 0
          geometry.colors = colors
          var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, opacity: 0.8, transparent: true })
          arcObject = new THREE.Line(geometry, material, THREE.LinePieces)
          globe.scene.add(arcObject)

          if (headGeometry.vertices.length) {
            headGeometry.colors = headColors
            var headMaterial = new THREE.PointCloudMaterial({
              size: 4.2,
              vertexColors: THREE.VertexColors,
              opacity: 0.9,
              transparent: true,
              depthWrite: false,
            })
            arcHeadObject = new THREE.PointCloud(headGeometry, headMaterial)
            globe.scene.add(arcHeadObject)
          }

          return renderedArcs
        }

        function renderFlow(data) {
          clearOverlayObject('flow')
          if (!data || data.enabled !== true) return 0
          var vectors = Array.isArray(data.vectors) ? data.vectors : []
          if (!vectors.length) return 0
          vectors = vectors.slice(0, currentRenderPolicy.maxFlow)

          var geometry = new THREE.Geometry()
          for (var i = 0; i < vectors.length; i++) {
            var vector = vectors[i]
            if (!vector || typeof vector !== 'object') continue
            var lat = Number(vector.lat)
            var lon = Number(vector.lon)
            var bearing = Number(vector.bearing)
            var magnitude = Math.max(0.1, Math.min(1, Number(vector.magnitude) || 0.2))
            if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(bearing)) continue

            var latOffset = Math.cos((bearing * Math.PI) / 180) * magnitude * 1.4
            var lonOffset = Math.sin((bearing * Math.PI) / 180) * magnitude * 1.8
            geometry.vertices.push(latLonToVector(lat, lon, 204.0), latLonToVector(lat + latOffset, lon + lonOffset, 207.0))
          }

          if (!geometry.vertices.length) return 0
          var material = new THREE.LineBasicMaterial({ color: 0x22d3ee, opacity: 0.55, transparent: true })
          flowObject = new THREE.Line(geometry, material, THREE.LinePieces)
          globe.scene.add(flowObject)
          return geometry.vertices.length / 2
        }

        function renderGrouping(data) {
          clearGroupObjects()
          if (!data || data.enabled !== true) return 0
          var clusters = Array.isArray(data.clusters) ? data.clusters : []
          if (!clusters.length) return 0
          clusters = clusters.slice(0, currentRenderPolicy.maxGroups)

          var rendered = 0
          for (var i = 0; i < clusters.length; i++) {
            var cluster = clusters[i]
            if (!cluster || typeof cluster !== 'object') continue
            var points = Array.isArray(cluster.points) ? cluster.points : []
            if (!points.length) continue

            var geometry = new THREE.Geometry()
            for (var j = 0; j < points.length; j++) {
              var point = points[j]
              if (!Array.isArray(point) || point.length < 2) continue
              var lat = Number(point[0])
              var lon = Number(point[1])
              if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
              geometry.vertices.push(latLonToVector(lat, lon, 204.6))
            }

            if (!geometry.vertices.length) continue
            var color = (cluster.color && typeof cluster.color === 'string') ? cluster.color : '#38bdf8'
            var material = new THREE.PointCloudMaterial({ color: color, size: 2.4, opacity: 0.52, transparent: true, depthWrite: false })
            var object = new THREE.PointCloud(geometry, material)
            globe.scene.add(object)
            groupObjects.push(object)
            rendered += 1
          }

          return rendered
        }

        function renderTemperature(data) {
          clearOverlayObject('temperature')
          if (!data || data.enabled !== true || !data.layer) return 0
          var layer = data.layer
          var points = Array.isArray(layer.points) ? layer.points : []
          if (!points.length) return 0

          var coldThreshold = Number(layer.coldThreshold)
          if (!Number.isFinite(coldThreshold)) coldThreshold = 0.3
          var hotThreshold = Number(layer.hotThreshold)
          if (!Number.isFinite(hotThreshold)) hotThreshold = 0.7
          hotThreshold = Math.max(coldThreshold + 0.05, hotThreshold)

          var geometry = new THREE.Geometry()
          var colors = []
          for (var i = 0; i < points.length; i++) {
            var point = points[i]
            if (!Array.isArray(point) || point.length < 3) continue
            var lat = Number(point[0])
            var lon = Number(point[1])
            var scaled = Number(point[2])
            if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(scaled)) continue
            geometry.vertices.push(latLonToVector(lat, lon, 206.2))

            var color
            if (scaled <= coldThreshold) {
              color = new THREE.Color(0x38bdf8)
            } else if (scaled >= hotThreshold) {
              color = new THREE.Color(0xef4444)
            } else {
              color = new THREE.Color(0xf59e0b)
            }
            colors.push(color)
          }

          if (!geometry.vertices.length) return 0
          geometry.colors = colors
          var material = new THREE.PointCloudMaterial({ size: 2.8, vertexColors: THREE.VertexColors, opacity: 0.6, transparent: true, depthWrite: false })
          temperatureObject = new THREE.PointCloud(geometry, material)
          globe.scene.add(temperatureObject)
          return geometry.vertices.length
        }

        function renderAnchor(data) {
          clearOverlayObject('anchor')
          if (!data || data.enabled !== true || !data.layer) return 0
          var layer = data.layer
          var points = Array.isArray(layer.related) ? layer.related : []
          if (!points.length) return 0

          var geometry = new THREE.Geometry()
          for (var i = 0; i < points.length; i++) {
            var point = points[i]
            if (!Array.isArray(point) || point.length < 2) continue
            var lat = Number(point[0])
            var lon = Number(point[1])
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
            geometry.vertices.push(latLonToVector(lat, lon, 205.4))
          }

          if (!geometry.vertices.length) return 0
          var material = new THREE.PointCloudMaterial({ color: 0xf472b6, size: 3.1, opacity: 0.65, transparent: true, depthWrite: false })
          anchorObject = new THREE.PointCloud(geometry, material)
          globe.scene.add(anchorObject)
          return geometry.vertices.length
        }

        function renderGroundHeat(data) {
          clearOverlayObject('groundHeat')
          if (!data || data.enabled !== true) return 0
          var cells = Array.isArray(data.cells) ? data.cells : []
          if (!cells.length) return 0

          var geometry = new THREE.Geometry()
          var colors = []
          for (var i = 0; i < cells.length; i++) {
            var cell = cells[i]
            if (!cell || typeof cell !== 'object') continue
            var lat = Number(cell.lat)
            var lon = Number(cell.lon)
            var intensity = Math.max(0.05, Math.min(1, Number(cell.intensity) || 0.1))
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
            geometry.vertices.push(latLonToVector(lat, lon, 200.8))
            colors.push(blendColor(0x1d4ed8, 0xef4444, intensity))
          }

          if (!geometry.vertices.length) return 0
          geometry.colors = colors
          var material = new THREE.PointCloudMaterial({ size: 6.3, vertexColors: THREE.VertexColors, opacity: 0.28, transparent: true, depthWrite: false })
          groundHeatObject = new THREE.PointCloud(geometry, material)
          globe.scene.add(groundHeatObject)
          return geometry.vertices.length
        }

        function renderBaseDots(flatPoints, pointOpacity) {
          clearOverlayObject('baseDots')
          if (!Array.isArray(flatPoints) || !flatPoints.length) return 0

          var geometry = new THREE.Geometry()
          var colors = []
          for (var i = 0; i < flatPoints.length; i += 3) {
            var lat = Number(flatPoints[i])
            var lon = Number(flatPoints[i + 1])
            var mag = Number(flatPoints[i + 2])
            if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(mag)) continue
            geometry.vertices.push(latLonToVector(lat, lon, 202.2))
            colors.push(colorFn(Math.max(0, Math.min(1, mag))))
          }

          if (!geometry.vertices.length) return 0
          geometry.colors = colors
          var material = new THREE.PointCloudMaterial({
            size: 3.2 * currentRenderPolicy.baseDotScale,
            vertexColors: THREE.VertexColors,
            transparent: true,
            opacity: Math.max(0.35, Math.min(1, Number(pointOpacity) || 0.9)),
            depthWrite: false,
          })
          baseDotsObject = new THREE.PointCloud(geometry, material)
          globe.scene.add(baseDotsObject)
          return geometry.vertices.length
        }

        function renderCityIndicators(flatPoints) {
          clearOverlayObject('cityIndicators')
          clearOverlayObject('cityIndicatorHalos')
          if (!Array.isArray(flatPoints) || !flatPoints.length) return 0
          if (!(currentViewLevel === 'county' || currentViewLevel === 'city' || currentViewLevel === 'state')) return 0

          var tuples = []
          for (var i = 0; i < flatPoints.length; i += 3) {
            var lat = Number(flatPoints[i])
            var lon = Number(flatPoints[i + 1])
            var mag = Number(flatPoints[i + 2])
            if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(mag)) continue
            tuples.push({ lat: lat, lon: lon, mag: Math.max(0, Math.min(1, mag)) })
          }

          tuples.sort(function (a, b) {
            return b.mag - a.mag
          })
          tuples = tuples.slice(0, currentRenderPolicy.maxCityIndicators)
          if (!tuples.length) return 0

          var geometry = new THREE.Geometry()
          var haloGeometry = new THREE.Geometry()
          var colors = []
          for (var t = 0; t < tuples.length; t++) {
            var item = tuples[t]
            var pointVertex = latLonToVector(item.lat, item.lon, 204.3)
            geometry.vertices.push(pointVertex)
            colors.push(blendColor(0x93c5fd, 0xf59e0b, item.mag))
            if (t < Math.max(8, Math.round(currentRenderPolicy.maxCityIndicators * 0.22))) {
              haloGeometry.vertices.push(pointVertex.clone())
            }
          }

          geometry.colors = colors
          var material = new THREE.PointCloudMaterial({
            size: 5.2 * currentRenderPolicy.cityIndicatorScale,
            vertexColors: THREE.VertexColors,
            transparent: true,
            opacity: 0.86,
            depthWrite: false,
          })
          cityIndicatorObject = new THREE.PointCloud(geometry, material)
          globe.scene.add(cityIndicatorObject)

          if (haloGeometry.vertices.length) {
            var haloMaterial = new THREE.PointCloudMaterial({
              color: 0xfef3c7,
              size: 8.2 * currentRenderPolicy.cityIndicatorScale,
              transparent: true,
              opacity: 0.36,
              depthWrite: false,
            })
            cityIndicatorHaloObject = new THREE.PointCloud(haloGeometry, haloMaterial)
            globe.scene.add(cityIndicatorHaloObject)
          }

          return geometry.vertices.length
        }

        function renderCountyLineOverlay(regionLayer, contextLayer) {
          if (countyLineObject) {
            globe.scene.remove(countyLineObject)
            disposeObjectTree(countyLineObject)
            countyLineObject = null
          }

          var countyLayer = null
          if (regionLayer && regionLayer.level === 'county') countyLayer = regionLayer
          else if (contextLayer && contextLayer.level === 'county') countyLayer = contextLayer
          if (!countyLayer) return 0

          var features = Array.isArray(countyLayer.features) ? countyLayer.features : []
          if (!features.length) return 0

          var geometry = new THREE.Geometry()
          var selectedKey = typeof countyLayer.selectedKey === 'string' ? countyLayer.selectedKey : ''

          for (var i = 0; i < features.length; i++) {
            var feature = features[i]
            if (!feature || typeof feature !== 'object') continue
            if (selectedKey && feature.key === selectedKey) continue

            var paths = Array.isArray(feature.paths) ? feature.paths : []
            for (var p = 0; p < paths.length; p++) {
              var coords = paths[p]
              if (!Array.isArray(coords) || coords.length < 2) continue
              var denseCoords = densifyRing(coords, 0.8)
              var ringCoords = denseCoords.length ? denseCoords : coords
              var ring = []
              for (var j = 0; j < ringCoords.length; j++) {
                var pair = ringCoords[j]
                if (!Array.isArray(pair) || pair.length < 2) continue
                var lon = Number(pair[0])
                var lat = Number(pair[1])
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue
                ring.push(latLonToVector(lat, lon, 203.5))
              }
              for (var r = 0; r < ring.length - 1; r++) {
                geometry.vertices.push(ring[r], ring[r + 1])
              }
            }
          }

          if (!geometry.vertices.length) return 0
          var material = new THREE.LineBasicMaterial({
            color: 0x7dd3fc,
            opacity: Math.min(0.92, 0.42 * currentRenderPolicy.countyContextBoost),
            transparent: true,
          })
          countyLineObject = new THREE.Line(geometry, material, THREE.LinePieces)
          globe.scene.add(countyLineObject)
          return geometry.vertices.length / 2
        }

        function extractTopCityLabels(regionLayer, contextLayer) {
          var cityLayer = null
          if (regionLayer && regionLayer.level === 'city') cityLayer = regionLayer
          else if (contextLayer && contextLayer.level === 'city') cityLayer = contextLayer
          if (!cityLayer) return []

          var features = Array.isArray(cityLayer.features) ? cityLayer.features : []
          return features
            .slice()
            .sort(function (a, b) {
              var left = Number(a && a.totalValue) || 0
              var right = Number(b && b.totalValue) || 0
              return right - left
            })
            .slice(0, 3)
            .map(function (feature) {
              return feature && typeof feature.label === 'string' ? feature.label : null
            })
            .filter(function (value) {
              return Boolean(value)
            })
        }

        function resetPoints() {
          if (frameTimer) {
            clearInterval(frameTimer)
            frameTimer = null
          }
          currentFrame = 0
          clearHighlights()
          clearRegionOutlines()
          clearAdvancedOverlays()
          legendEl.textContent = ''
          if (!globe.points) return
          globe.scene.remove(globe.points)
          if (globe.points.geometry && globe.points.geometry.dispose) globe.points.geometry.dispose()
          if (globe.points.material && globe.points.material.dispose) globe.points.material.dispose()
          globe.points = null
          globe._baseGeometry = undefined
          globe._morphTargetId = undefined
          globe.is_animated = false
        }

        function normalizePoints(value) {
          if (!Array.isArray(value)) return []
          var points = []
          for (var i = 0; i < value.length; i++) {
            var item = value[i]
            if (!Array.isArray(item) || item.length < 3) continue
            var lat = Number(item[0])
            var lon = Number(item[1])
            var mag = Number(item[2])
            if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(mag)) continue
            points.push(lat, lon, Math.max(0.02, mag))
          }
          return points
        }

        function frameTimeFor(index, frameCount) {
          if (frameCount <= 1) return 0
          return index / (frameCount - 1)
        }

        function animateToFrame(index, frameCount) {
          var t = frameTimeFor(index, frameCount)
          if (window.TWEEN && typeof TWEEN.Tween === 'function') {
            new TWEEN.Tween(globe)
              .to({ time: t }, 680)
              .easing(TWEEN.Easing.Cubic.EaseOut)
              .start()
          } else {
            globe.time = t
          }
        }

        function normalizeFrames(value) {
          if (!Array.isArray(value)) return []
          var frames = []
          for (var i = 0; i < value.length; i++) {
            var frame = value[i]
            if (!frame || typeof frame !== 'object') continue
            var points = normalizePoints(frame.points)
            if (!points.length) continue
            var name = typeof frame.name === 'string' && frame.name.trim() ? frame.name.trim() : 'Frame ' + (i + 1)
            frames.push({ name: name, points: points })
          }
          return frames
        }

        function applyView(view) {
          if (!view || typeof view !== 'object') return

          regionQualityDebug = view.regionQualityDebug === true
          if (typeof view.activeLevel === 'string') {
            currentViewLevel = view.activeLevel
          }
          updateRenderPolicy()

          var earthStyle = view.earthStyle
          currentEarthStyle = earthStyle || 'grey'
          var localView = currentViewLevel === 'state' || currentViewLevel === 'county' || currentViewLevel === 'city'
          if (earthStyle === 'atlas') {
            globe.renderer.domElement.style.filter = localView
              ? 'sepia(0.55) saturate(1.0) contrast(1.12) brightness(1.04) hue-rotate(-8deg)'
              : 'sepia(0.72) saturate(0.85) contrast(1.07) brightness(1.02) hue-rotate(-10deg)'
          } else if (earthStyle === 'neon') {
            globe.renderer.domElement.style.filter = localView
              ? 'saturate(1.7) contrast(1.3) brightness(1.08) hue-rotate(12deg)'
              : 'saturate(2.05) contrast(1.42) brightness(1.12) hue-rotate(16deg)'
          } else if (earthStyle === 'blueprint') {
            globe.renderer.domElement.style.filter = localView
              ? 'grayscale(0.5) saturate(1.45) contrast(1.2) brightness(1.08) hue-rotate(170deg)'
              : 'grayscale(0.72) saturate(1.38) contrast(1.22) brightness(1.04) hue-rotate(168deg)'
          } else {
            globe.renderer.domElement.style.filter = localView
              ? 'grayscale(0.62) saturate(0.7) contrast(1.2) brightness(1.03)'
              : 'grayscale(0.94) saturate(0.35) contrast(1.16) brightness(0.96)'
          }

          if (earthStyleShell && earthStyleShell.material) {
            if (earthStyle === 'atlas') {
              earthStyleShell.material.color.set(0xf59e0b)
              earthStyleShell.material.opacity = 0.1
            } else if (earthStyle === 'neon') {
              earthStyleShell.material.color.set(0x38bdf8)
              earthStyleShell.material.opacity = 0.12
            } else if (earthStyle === 'blueprint') {
              earthStyleShell.material.color.set(0x60a5fa)
              earthStyleShell.material.opacity = 0.11
            } else {
              earthStyleShell.material.color.set(0xd1d5db)
              earthStyleShell.material.opacity = 0.09
            }
          }

          var bg = view.backgroundStyle
          if (bg === 'black') {
            bgEl.setAttribute('data-style', 'black')
          } else if (bg === 'steel') {
            bgEl.setAttribute('data-style', 'steel')
          } else {
            bgEl.setAttribute('data-style', 'deep-space')
          }

          currentZoomScale = Math.max(0.75, Math.min(2.3, Number(view.zoomScale) || 1))

          if (globe.points && globe.points.material) {
            globe.points.material.transparent = true
            var opacity = Number(view.pointOpacity)
            if (!Number.isFinite(opacity)) opacity = 0.95
            globe.points.material.opacity = Math.max(0.35, Math.min(1, opacity))
          }

          desiredAutoRotateEnabled = view.autoRotate === true
          var speed = Number(view.autoRotateSpeed)
          if (!Number.isFinite(speed)) speed = 0.06
          desiredAutoRotateSpeed = Math.max(0.005, Math.min(0.12, speed))
          applyAdaptiveAutoRotate()
          updateReferenceOverlays(view)

          updateZoomResponsiveScales()
        }

        function applyFocus(focus, showFocusLabel) {
          if (!focus || typeof focus !== 'object') {
            focusEl.textContent = ''
            setFocusAnchor(NaN, NaN)
            return
          }

          var lat = Number(focus.lat)
          var lon = Number(focus.lon)
          var zoomDistance = Number(focus.zoomDistance)
          var requestId = Number(focus.requestId)
          var hasNewRequest = Number.isFinite(requestId) ? requestId !== lastFocusRequestId : true

          if (hasNewRequest) {
            if (Number.isFinite(lat) && Number.isFinite(lon) && typeof globe.focusLatLon === 'function') {
              globe.focusLatLon(lat, lon)
            }
            if (Number.isFinite(zoomDistance) && typeof globe.setZoomTarget === 'function') {
              globe.setZoomTarget(zoomDistance)
            }
            setFocusAnchor(lat, lon)
            if (Number.isFinite(requestId)) {
              lastFocusRequestId = requestId
            }
            focusHoldUntil = Date.now() + 3000
            updateRenderPolicy()
            applyAdaptiveAutoRotate()
          }

          if (showFocusLabel !== false) {
            var label = typeof focus.label === 'string' ? focus.label : 'Focused region'
            focusEl.textContent = 'Focused: ' + label
          } else {
            focusEl.textContent = ''
          }
        }

        function update(payload) {
          var updateStart = window.performance && typeof window.performance.now === 'function' ? window.performance.now() : Date.now()
          var title = typeof payload.title === 'string' ? payload.title : 'Geo Intelligence'
          var subtitle = typeof payload.subtitle === 'string' ? payload.subtitle : ''

          resetPoints()
          titleEl.textContent = title

          var frames = normalizeFrames(payload.frames)
          if (!frames.length) {
            subtitleEl.textContent = subtitle || 'No plottable points in payload.'
            return
          }

          var playback = payload.playback && typeof payload.playback === 'object' ? payload.playback : {}
          var autoplay = playback.autoplay !== false
          var speedMs = Number(playback.speedMs)
          if (!Number.isFinite(speedMs) || speedMs < 650) speedMs = 1300

          var selectedFrame = Number(playback.selectedFrame)
          if (!Number.isFinite(selectedFrame)) selectedFrame = 0
          selectedFrame = Math.max(0, Math.min(frames.length - 1, Math.floor(selectedFrame)))

          var view = payload.view && typeof payload.view === 'object' ? payload.view : {}
          applyView(view)

          var animated = frames.length > 1
          for (var i = 0; i < frames.length; i++) {
            globe.addData(frames[i].points, {
              format: 'magnitude',
              animated: animated,
              name: frames[i].name,
            })
          }
          globe.createPoints()

          applyView(view)
          applyFocus(payload.focus, view.showFocusLabel)
          updateReferenceOverlays(view)
          var regionSummary = renderRegionLayer(payload.regionLayer)
          var contextSummary = renderContextLayer(payload.contextLayer, view.contextTheme)
          var countyLineCount = renderCountyLineOverlay(payload.regionLayer, payload.contextLayer)
          var topCityLabels = extractTopCityLabels(payload.regionLayer, payload.contextLayer)

          function applyBaseVisual(index) {
            var mode = typeof view.baseVisual === 'string' ? view.baseVisual : 'hybrid'
            var framePoints = frames[index] ? frames[index].points : []

            if (globe.points && globe.points.material) {
              globe.points.material.transparent = true
              if (mode === 'dots') {
                globe.points.material.opacity = 0.02
              } else if (mode === 'spikes') {
                globe.points.material.opacity = Math.max(0.35, Math.min(1, Number(view.pointOpacity) || 0.95))
              } else {
                globe.points.material.opacity = Math.max(0.22, Math.min(0.78, Number(view.pointOpacity) || 0.95))
              }
            }

            if (mode === 'spikes') {
              clearOverlayObject('baseDots')
            } else {
              renderBaseDots(framePoints, view.pointOpacity)
            }

            renderCityIndicators(framePoints)
          }

          if (view.showRegionHighlight !== false) {
            renderHighlights(payload.highlights, view.pointOpacity)
          }

          var arcCount = renderConnections(payload.connections)
          var flowCount = renderFlow(payload.flow)
          var groupCount = renderGrouping(payload.grouping)
          var tempCount = renderTemperature(payload.temperature)
          var anchorCount = renderAnchor(payload.anchor)
          var heatCount = renderGroundHeat(payload.groundHeat)
          var cityIndicatorCount = renderCityIndicators(frames[selectedFrame] ? frames[selectedFrame].points : [])

          var legendParts = []
          if (arcCount > 0) legendParts.push('arcs: ' + arcCount)
          if (flowCount > 0) legendParts.push('flow: ' + flowCount)
          if (groupCount > 0) legendParts.push('groups: ' + groupCount)
          if (tempCount > 0) legendParts.push('temperature: ' + tempCount)
          if (anchorCount > 0) legendParts.push('anchor-related: ' + anchorCount)
          if (heatCount > 0) legendParts.push('ground heat: ' + heatCount)
          if (cityIndicatorCount > 0) legendParts.push('city indicators: ' + cityIndicatorCount)
          if (countyLineCount > 0) legendParts.push('county lines: ' + countyLineCount)
          if (topCityLabels.length) legendParts.push('top cities: ' + topCityLabels.join(', '))
          if (contextSummary && contextSummary.total > 0) {
            var contextLevel = payload.contextLayer && typeof payload.contextLayer.level === 'string' ? payload.contextLayer.level : 'context'
            legendParts.push('context ' + contextLevel + ': ' + contextSummary.total)
          }
          if (regionQualityDebug && regionSummary && regionSummary.total > 0) {
            legendParts.push('region quality high/med/low: ' + regionSummary.high + '/' + regionSummary.medium + '/' + regionSummary.low)
            legendParts.push('strategy hull/bbox/deg: ' + regionSummary.hull + '/' + regionSummary.bbox + '/' + regionSummary.degenerate)
            if (contextSummary && contextSummary.total > 0) {
              legendParts.push('context quality high/med/low: ' + contextSummary.high + '/' + contextSummary.medium + '/' + contextSummary.low)
              legendParts.push('context strategy hull/bbox/deg: ' + contextSummary.hull + '/' + contextSummary.bbox + '/' + contextSummary.degenerate)
            }
            if (typeof view.regionTriageMode === 'string' && view.regionTriageMode !== 'all') {
              legendParts.push('triage: ' + view.regionTriageMode)
            } else if (view.regionLowQualityOnly === true) {
              legendParts.push('triage: low-quality only')
            }
            legendParts.push('cache hit/miss: ' + densifyCacheHits + '/' + densifyCacheMisses)
          }

          var updateEnd = window.performance && typeof window.performance.now === 'function' ? window.performance.now() : Date.now()
          var elapsed = Math.max(0, updateEnd - updateStart)
          renderTiming.lastMs = elapsed
          renderTiming.count += 1
          renderTiming.totalMs += elapsed
          renderTiming.maxMs = Math.max(renderTiming.maxMs, elapsed)
          var avgMs = renderTiming.totalMs / Math.max(1, renderTiming.count)
          legendParts.push('render ms L/A/M: ' + elapsed.toFixed(1) + '/' + avgMs.toFixed(1) + '/' + renderTiming.maxMs.toFixed(1))

          legendEl.textContent = legendParts.length ? 'Layers  ' + legendParts.join('  ') : ''

          updateZoomResponsiveScales()

          function setSubtitle(index) {
            subtitleEl.textContent = subtitle + (frames[index] ? '  ' + frames[index].name : '')
          }

          currentFrame = selectedFrame
          applyBaseVisual(currentFrame)
          setSubtitle(currentFrame)
          if (!animated) {
            globe.time = 0
            return
          }

          animateToFrame(currentFrame, frames.length)
          if (!autoplay) return

          frameTimer = setInterval(function () {
            currentFrame = (currentFrame + 1) % frames.length
            animateToFrame(currentFrame, frames.length)
            applyBaseVisual(currentFrame)
            setSubtitle(currentFrame)
          }, speedMs)
        }

        window.addEventListener('message', function (event) {
          var payload = event && event.data
          if (!payload || payload.type !== 'splunk-nextgen:data') return
          update(payload.payload || {})
        })

        window.addEventListener('resize', function () {
          if (globe.renderer && globe.renderer.setSize) {
            globe.renderer.setSize(container.offsetWidth, container.offsetHeight)
          }
          applyAdaptiveAutoRotate()
          updateReferenceOverlays()
          updateZoomResponsiveScales()
        })

        container.addEventListener('mousedown', function (event) {
          pointerDown = {
            x: event.clientX,
            y: event.clientY,
            time: Date.now(),
            moved: false,
          }
        })

        container.addEventListener('mousemove', function (event) {
          if (!pointerDown) return
          var dx = event.clientX - pointerDown.x
          var dy = event.clientY - pointerDown.y
          if (Math.sqrt(dx * dx + dy * dy) > 8) {
            pointerDown.moved = true
          }
        })

        container.addEventListener('mouseup', function (event) {
          if (!pointerDown) return
          var pressDuration = Date.now() - pointerDown.time
          var dragged = pointerDown.moved === true
          pointerDown = null
          if (dragged || pressDuration > 280) return

          if (!globe || !globe.camera || !globe.renderer || !globe.renderer.domElement) return
          var canvas = globe.renderer.domElement
          var rect = canvas.getBoundingClientRect()
          if (!rect.width || !rect.height) return

          var x = ((event.clientX - rect.left) / rect.width) * 2 - 1
          var y = -(((event.clientY - rect.top) / rect.height) * 2 - 1)
          var origin = globe.camera.position.clone()
          var direction = new THREE.Vector3(x, y, 0.5)
          direction.unproject(globe.camera)
          direction.sub(origin).normalize()

          var radius = 200
          var a = direction.dot(direction)
          var b = 2 * origin.dot(direction)
          var c = origin.dot(origin) - radius * radius
          var discriminant = b * b - 4 * a * c
          if (discriminant < 0) return

          var sqrt = Math.sqrt(discriminant)
          var t1 = (-b - sqrt) / (2 * a)
          var t2 = (-b + sqrt) / (2 * a)
          var t = t1 > 0 ? t1 : t2 > 0 ? t2 : -1
          if (t <= 0) return

          var hit = origin.clone().add(direction.clone().multiplyScalar(t))
          var lat = (Math.asin(hit.y / radius) * 180) / Math.PI
          var lon = 180 - (Math.atan2(hit.z, hit.x) * 180) / Math.PI
          while (lon > 180) lon -= 360
          while (lon < -180) lon += 360

          window.parent.postMessage(
            {
              type: 'splunk-nextgen:globe-click',
              payload: { lat: lat, lon: lon },
            },
            '*',
          )
        })

        container.addEventListener('mouseleave', function () {
          pointerDown = null
        })

        setInterval(function () {
          updateRenderPolicy()
          applyAdaptiveAutoRotate()
          updateReferenceOverlays()
          updateZoomResponsiveScales()
        }, 180)
      })()
    </script>
  </body>
</html>
